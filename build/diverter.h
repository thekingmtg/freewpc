
/* This file was autogenerated by 'ctemp' from  for class divhold. */


#include <freewpc.h>

#define DIVERTER_MODE 0 // 1 == fliptronics, 0 == normal

// Note: The driver doesn't care about any switches.
/* Schedule this driver every 32 ms. */
#define DIVERTER_DIVERTER_SCHED 32 // see the 'schedule_ms' driver parameter

/* Length of time for the initial power pulse */
#define DIVERTER_POWER_PULSE 64 // must be divisible exactly by DIVERTER_DIVERTER_SCHED (above), see the 'power_pulse_ms' driver parameter 
#define DIVERTER_POWER_TICKS (DIVERTER_POWER_PULSE / DIVERTER_DIVERTER_SCHED)

extern __fastram__ S8 diverter_timer;


void diverter_start (void);
void diverter_stop (void);

#if (DIVERTER_MODE > 0)

extern U8 fliptronic_powered_coil_outputs;
#define diverter_sol_bitmask(id) (1 << ((id & (CHAR_BIT - 1))))

#define diverter_sol_contribute(id, bits, enable) \
	{ if (enable) { bits |= diverter_sol_bitmask(id); } else { bits &= ~(diverter_sol_bitmask(id)); } };

#define diverter_sol_enable(id, bits) \
	{ bits |= diverter_sol_bitmask(id); };

#define diverter_sol_disable(id, bits) \
 	{ bits &= ~(diverter_sol_bitmask(id)); };
#endif

extern inline void diverter_service (void)
{
#if (DIVERTER_MODE > 0)
	register U8 out __areg__ = fliptronic_powered_coil_outputs;
#endif
	
	if (diverter_timer == 0) {
#if (DIVERTER_MODE > 0)	
		diverter_sol_disable(SOL_DIVERTER_POWER, out);
		diverter_sol_disable(SOL_DIVERTER_HOLD, out);
#else
		sol_disable (SOL_DIVERTER_POWER);
		sol_disable (SOL_DIVERTER_HOLD);
#endif
	} 
	
	if (diverter_timer > 0) {
		/* Allow the high power pulse to keep running */
#if (DIVERTER_MODE > 0)
		diverter_sol_enable(SOL_DIVERTER_POWER, out);
		diverter_sol_enable(SOL_DIVERTER_HOLD, out);
#else
		sol_enable (SOL_DIVERTER_POWER);
		sol_enable (SOL_DIVERTER_HOLD);
#endif
		
		if (--diverter_timer == 0)
		{
			diverter_timer = -1;
			/* The high power pulse has expired.  Switch to hold power */			
#if (DIVERTER_MODE > 0)
			diverter_sol_disable(SOL_DIVERTER_POWER, out);			
#else
			sol_disable (SOL_DIVERTER_POWER);
#endif
		}
	}
	
	if (diverter_timer < 0) {
		/* Allow the hold power to keep running */
#if (DIVERTER_MODE > 0)
		diverter_sol_enable(SOL_DIVERTER_HOLD, out);
#else
		sol_enable (SOL_DIVERTER_HOLD);
#endif
		// We could add a timeout here so that we don't stay on hold power forever but that 
		// is better left to the game logic, e.g. via timed modes, switches etc.
		// On the Willimans Corvette original ROM code the diverter stays on for a while, and
		// then turns off if the ball hasn't been up the ramp.  Then if a ball should go up
		// the ramp while the diverter is off an opto is triggered near the bottom of the
		// ramp which is then used to determine if the diverter should be re-opened.
	}
	
#if (DIVERTER_MODE > 0)	
	/* Write the final output to the hardware */
	fliptronic_powered_coil_outputs = out;
#endif	
}

